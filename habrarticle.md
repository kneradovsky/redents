
React и Redux, в последнее время одни из самых популярных buzz-words в мире фронтенда. Поэтому когда мне потребовалось сделать веб-приложение, которое бы отображало данные, полученные с сервера, а также позволяло бы ими манипулировать (создавать, удалять и изменять), я решил построить его на основе связки React и Redux. Множество getting-started руководств покрывают только функционал создания компонентов, action creators и reducers. Но как только дело касается обмена с сервером, начинаются сложности - растет количество необходимых action creator, редьюсеров. Причем они очень похожи друг на друга, с миниальными отличиями. В большинстве случаев - только в типе (имени) активности. После того, как я создал третий одинаковый набор креаторов и редьюсеров, то появилось желание что-то изменить. Так родилась идея реализации redux-redents.

## Начало, dictionary reducers
В общем виде, reducers очень похожи друг на друга - принять свой action и создать на его основе новое состояние хранилища. Если рассматривать reducers для обработки ответа с сервера, то они будут отличаться только типом action. Так родилась идея "универсального" редьюсера:

```javascript
function createReducer(acttype,initialState) {
	return (state = initialState, action) => {
		if(action.type!=acttype) return state;
		return action.res.data;
	};
}

const dicts = {
  type1 : createReducer(TYPE1_CONSTANT,{}),
  type2 : createReducer(TYPE2_CONSTANT,[])
}

const rootReducer = combineReducers({...dicts});
```

Уже это позволяет не писать одинаковые функции и не городить switch-case конструкции.

## Константы. Избавление.

Словарь редьюсеров сократил количество одинакового кода, но остались константы для задания типов action. Добавление нового action и его обработчика выглядит так:
1. создать константу для типа action
2. создать action creator
3. создать обработчик createReducer с заданным типом.

Поддержка набора констант начинает раздражать практически сразу. Тем более, что смысла в них практически никакого нет - разработчик их использует только для связки creator и reducer. Таким образом константы можно заменить на соглашения о конфигурировании типов action.   
Далее - все action creators для получения данных с сервера выглядят одинаково - создать action с нужным типом и promise для запроса на сервер. Если они выглядят одинаково, то не лучше ли автоматизировать процесс создания creators, а еще лучше сделать универсальный creator?

Объединение двух идей - замена констант соглашениями и универсальный creator и привели рождению модуля.  

### Соглашения о данных
Если для обмена с сервером используется rest-like api, то для каждого типа данных у нас есть одинаковое число операций по-умолчанию: index (list), get, post, delete; а у каждой операции есть uri и параметры для передачи на сервер. Таким образом можно заключить соглашения об умолчаниях:
* каждый тип данных поддерживает стандартный набор операций
* для каждой операции определены правила вычисления url и параметров

Кроме этого нужно предусмотреть возможность расширения:
* добавление операций
* конструирование запроса

В результате появился следующий формат:
```javascript
entities = {
  fruit : {}, //all default
  vegetable: {
    crop : { //custom operation
      type: 'CROP_VEGETABLE',
      request: (data) => return post(url,data) //custom request
    },
    index: {
      url: url1 //custom url
    }
  }
}   
```

### Универсальный action creator
Используя соглашения осталось реализовать только 
